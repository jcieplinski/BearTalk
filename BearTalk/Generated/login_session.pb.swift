// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: login_session.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Mobilegateway_Protos_NotificationChannelType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// No idea what these actually mean, but these are the only accepted values 
  case notificationChannelUnknown // = 0

  /// One of these is FIREBASE 
  case notificationChannelOne // = 1
  case notificationChannelTwo // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .notificationChannelUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notificationChannelUnknown
    case 1: self = .notificationChannelOne
    case 2: self = .notificationChannelTwo
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notificationChannelUnknown: return 0
    case .notificationChannelOne: return 1
    case .notificationChannelTwo: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Mobilegateway_Protos_NotificationChannelType] = [
    .notificationChannelUnknown,
    .notificationChannelOne,
    .notificationChannelTwo,
  ]

}

public enum Mobilegateway_Protos_Os: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0

  /// Could have these backwards 
  case ios // = 1
  case android // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .ios
    case 2: self = .android
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .ios: return 1
    case .android: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Mobilegateway_Protos_Os] = [
    .unknown,
    .ios,
    .android,
  ]

}

public enum Mobilegateway_Protos_Subscription: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0
  case charge // = 1
  case security // = 2
  case software // = 3
  case hvac // = 4
  case `required` // = 5
  case cdrEmail // = 6
  case subscription // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .charge
    case 2: self = .security
    case 3: self = .software
    case 4: self = .hvac
    case 5: self = .required
    case 6: self = .cdrEmail
    case 7: self = .subscription
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .charge: return 1
    case .security: return 2
    case .software: return 3
    case .hvac: return 4
    case .required: return 5
    case .cdrEmail: return 6
    case .subscription: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Mobilegateway_Protos_Subscription] = [
    .unknown,
    .charge,
    .security,
    .software,
    .hvac,
    .required,
    .cdrEmail,
    .subscription,
  ]

}

public enum Mobilegateway_Protos_Encryption: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0
  case single // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .single
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .single: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Mobilegateway_Protos_Encryption] = [
    .unknown,
    .single,
  ]

}

public struct Mobilegateway_Protos_LoginRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var username: String = String()

  public var password: String = String()

  public var notificationChannelType: Mobilegateway_Protos_NotificationChannelType = .notificationChannelUnknown

  public var os: Mobilegateway_Protos_Os = .unknown

  public var notificationDeviceToken: String = String()

  public var locale: String = String()

  public var deviceID: String {
    get {return _deviceID ?? String()}
    set {_deviceID = newValue}
  }
  /// Returns true if `deviceID` has been explicitly set.
  public var hasDeviceID: Bool {return self._deviceID != nil}
  /// Clears the value of `deviceID`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceID() {self._deviceID = nil}

  public var clientName: String {
    get {return _clientName ?? String()}
    set {_clientName = newValue}
  }
  /// Returns true if `clientName` has been explicitly set.
  public var hasClientName: Bool {return self._clientName != nil}
  /// Clears the value of `clientName`. Subsequent reads from it will return its default value.
  public mutating func clearClientName() {self._clientName = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _deviceID: String? = nil
  fileprivate var _clientName: String? = nil
}

public struct Mobilegateway_Protos_SessionInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var idToken: String = String()

  public var expiryTimeSec: Int32 = 0

  public var refreshToken: String {
    get {return _refreshToken ?? String()}
    set {_refreshToken = newValue}
  }
  /// Returns true if `refreshToken` has been explicitly set.
  public var hasRefreshToken: Bool {return self._refreshToken != nil}
  /// Clears the value of `refreshToken`. Subsequent reads from it will return its default value.
  public mutating func clearRefreshToken() {self._refreshToken = nil}

  public var gigyaJwt: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _refreshToken: String? = nil
}

public struct Mobilegateway_Protos_LoginResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: String = String()

  public var sessionInfo: Mobilegateway_Protos_SessionInfo {
    get {return _sessionInfo ?? Mobilegateway_Protos_SessionInfo()}
    set {_sessionInfo = newValue}
  }
  /// Returns true if `sessionInfo` has been explicitly set.
  public var hasSessionInfo: Bool {return self._sessionInfo != nil}
  /// Clears the value of `sessionInfo`. Subsequent reads from it will return its default value.
  public mutating func clearSessionInfo() {self._sessionInfo = nil}

  public var userProfile: Mobilegateway_Protos_UserProfile {
    get {return _userProfile ?? Mobilegateway_Protos_UserProfile()}
    set {_userProfile = newValue}
  }
  /// Returns true if `userProfile` has been explicitly set.
  public var hasUserProfile: Bool {return self._userProfile != nil}
  /// Clears the value of `userProfile`. Subsequent reads from it will return its default value.
  public mutating func clearUserProfile() {self._userProfile = nil}

  public var userVehicleData: [Mobilegateway_Protos_Vehicle] = []

  public var subscriptions: [Mobilegateway_Protos_Subscription] = []

  public var encryption: Mobilegateway_Protos_Encryption = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sessionInfo: Mobilegateway_Protos_SessionInfo? = nil
  fileprivate var _userProfile: Mobilegateway_Protos_UserProfile? = nil
}

public struct Mobilegateway_Protos_GetNewJWTTokenRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var refreshToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Mobilegateway_Protos_GetNewJWTTokenResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionInfo: Mobilegateway_Protos_SessionInfo {
    get {return _sessionInfo ?? Mobilegateway_Protos_SessionInfo()}
    set {_sessionInfo = newValue}
  }
  /// Returns true if `sessionInfo` has been explicitly set.
  public var hasSessionInfo: Bool {return self._sessionInfo != nil}
  /// Clears the value of `sessionInfo`. Subsequent reads from it will return its default value.
  public mutating func clearSessionInfo() {self._sessionInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sessionInfo: Mobilegateway_Protos_SessionInfo? = nil
}

public struct Mobilegateway_Protos_ConfirmResetPinRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Mobilegateway_Protos_ConfirmResetPinResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Mobilegateway_Protos_GetSubscriptionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Mobilegateway_Protos_GetSubscriptionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subscriptions: [Mobilegateway_Protos_Subscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Mobilegateway_Protos_GetUserVehiclesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Mobilegateway_Protos_GetUserVehiclesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userVehicleData: [Mobilegateway_Protos_Vehicle] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Mobilegateway_Protos_LogoutRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Mobilegateway_Protos_LogoutResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Mobilegateway_Protos_RefreshNotificationTokenRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Mobilegateway_Protos_RefreshNotificationTokenResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Mobilegateway_Protos_SetNickNameRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var vehicleID: String = String()

  public var nickname: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Mobilegateway_Protos_SetNickNameResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Mobilegateway_Protos_SetSubscriptionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Mobilegateway_Protos_SetSubscriptionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "mobilegateway.protos"

extension Mobilegateway_Protos_NotificationChannelType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOTIFICATION_CHANNEL_UNKNOWN"),
    1: .same(proto: "NOTIFICATION_CHANNEL_ONE"),
    2: .same(proto: "NOTIFICATION_CHANNEL_TWO"),
  ]
}

extension Mobilegateway_Protos_Os: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OS_UNKNOWN"),
    1: .same(proto: "OS_IOS"),
    2: .same(proto: "OS_ANDROID"),
  ]
}

extension Mobilegateway_Protos_Subscription: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_UNKNOWN"),
    1: .same(proto: "SUBSCRIPTION_CHARGE"),
    2: .same(proto: "SUBSCRIPTION_SECURITY"),
    3: .same(proto: "SUBSCRIPTION_SOFTWARE"),
    4: .same(proto: "SUBSCRIPTION_HVAC"),
    5: .same(proto: "SUBSCRIPTION_REQUIRED"),
    6: .same(proto: "SUBSCRIPTION_CDR_EMAIL"),
    7: .same(proto: "SUBSCRIPTION_SUBSCRIPTION"),
  ]
}

extension Mobilegateway_Protos_Encryption: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ENCRYPTION_UNKNOWN"),
    1: .same(proto: "ENCRYPTION_SINGLE"),
  ]
}

extension Mobilegateway_Protos_LoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "password"),
    3: .standard(proto: "notification_channel_type"),
    4: .same(proto: "os"),
    5: .standard(proto: "notification_device_token"),
    6: .same(proto: "locale"),
    7: .standard(proto: "device_id"),
    8: .standard(proto: "client_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.notificationChannelType) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.os) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.notificationDeviceToken) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.locale) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._deviceID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._clientName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if self.notificationChannelType != .notificationChannelUnknown {
      try visitor.visitSingularEnumField(value: self.notificationChannelType, fieldNumber: 3)
    }
    if self.os != .unknown {
      try visitor.visitSingularEnumField(value: self.os, fieldNumber: 4)
    }
    if !self.notificationDeviceToken.isEmpty {
      try visitor.visitSingularStringField(value: self.notificationDeviceToken, fieldNumber: 5)
    }
    if !self.locale.isEmpty {
      try visitor.visitSingularStringField(value: self.locale, fieldNumber: 6)
    }
    try { if let v = self._deviceID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._clientName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mobilegateway_Protos_LoginRequest, rhs: Mobilegateway_Protos_LoginRequest) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.notificationChannelType != rhs.notificationChannelType {return false}
    if lhs.os != rhs.os {return false}
    if lhs.notificationDeviceToken != rhs.notificationDeviceToken {return false}
    if lhs.locale != rhs.locale {return false}
    if lhs._deviceID != rhs._deviceID {return false}
    if lhs._clientName != rhs._clientName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobilegateway_Protos_SessionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SessionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_token"),
    2: .standard(proto: "expiry_time_sec"),
    3: .standard(proto: "refresh_token"),
    4: .standard(proto: "gigya_jwt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idToken) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.expiryTimeSec) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._refreshToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.gigyaJwt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.idToken.isEmpty {
      try visitor.visitSingularStringField(value: self.idToken, fieldNumber: 1)
    }
    if self.expiryTimeSec != 0 {
      try visitor.visitSingularInt32Field(value: self.expiryTimeSec, fieldNumber: 2)
    }
    try { if let v = self._refreshToken {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.gigyaJwt.isEmpty {
      try visitor.visitSingularStringField(value: self.gigyaJwt, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mobilegateway_Protos_SessionInfo, rhs: Mobilegateway_Protos_SessionInfo) -> Bool {
    if lhs.idToken != rhs.idToken {return false}
    if lhs.expiryTimeSec != rhs.expiryTimeSec {return false}
    if lhs._refreshToken != rhs._refreshToken {return false}
    if lhs.gigyaJwt != rhs.gigyaJwt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobilegateway_Protos_LoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .standard(proto: "session_info"),
    3: .standard(proto: "user_profile"),
    4: .standard(proto: "user_vehicle_data"),
    5: .same(proto: "subscriptions"),
    6: .same(proto: "encryption"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sessionInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._userProfile) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.userVehicleData) }()
      case 5: try { try decoder.decodeRepeatedEnumField(value: &self.subscriptions) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.encryption) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    try { if let v = self._sessionInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._userProfile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.userVehicleData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userVehicleData, fieldNumber: 4)
    }
    if !self.subscriptions.isEmpty {
      try visitor.visitPackedEnumField(value: self.subscriptions, fieldNumber: 5)
    }
    if self.encryption != .unknown {
      try visitor.visitSingularEnumField(value: self.encryption, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mobilegateway_Protos_LoginResponse, rhs: Mobilegateway_Protos_LoginResponse) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs._sessionInfo != rhs._sessionInfo {return false}
    if lhs._userProfile != rhs._userProfile {return false}
    if lhs.userVehicleData != rhs.userVehicleData {return false}
    if lhs.subscriptions != rhs.subscriptions {return false}
    if lhs.encryption != rhs.encryption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobilegateway_Protos_GetNewJWTTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNewJWTTokenRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "refresh_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.refreshToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.refreshToken.isEmpty {
      try visitor.visitSingularStringField(value: self.refreshToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mobilegateway_Protos_GetNewJWTTokenRequest, rhs: Mobilegateway_Protos_GetNewJWTTokenRequest) -> Bool {
    if lhs.refreshToken != rhs.refreshToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobilegateway_Protos_GetNewJWTTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNewJWTTokenResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sessionInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sessionInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mobilegateway_Protos_GetNewJWTTokenResponse, rhs: Mobilegateway_Protos_GetNewJWTTokenResponse) -> Bool {
    if lhs._sessionInfo != rhs._sessionInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobilegateway_Protos_ConfirmResetPinRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfirmResetPinRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mobilegateway_Protos_ConfirmResetPinRequest, rhs: Mobilegateway_Protos_ConfirmResetPinRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobilegateway_Protos_ConfirmResetPinResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfirmResetPinResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mobilegateway_Protos_ConfirmResetPinResponse, rhs: Mobilegateway_Protos_ConfirmResetPinResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobilegateway_Protos_GetSubscriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSubscriptionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mobilegateway_Protos_GetSubscriptionRequest, rhs: Mobilegateway_Protos_GetSubscriptionRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobilegateway_Protos_GetSubscriptionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSubscriptionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.subscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriptions.isEmpty {
      try visitor.visitPackedEnumField(value: self.subscriptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mobilegateway_Protos_GetSubscriptionResponse, rhs: Mobilegateway_Protos_GetSubscriptionResponse) -> Bool {
    if lhs.subscriptions != rhs.subscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobilegateway_Protos_GetUserVehiclesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserVehiclesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mobilegateway_Protos_GetUserVehiclesRequest, rhs: Mobilegateway_Protos_GetUserVehiclesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobilegateway_Protos_GetUserVehiclesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserVehiclesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_vehicle_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.userVehicleData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userVehicleData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userVehicleData, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mobilegateway_Protos_GetUserVehiclesResponse, rhs: Mobilegateway_Protos_GetUserVehiclesResponse) -> Bool {
    if lhs.userVehicleData != rhs.userVehicleData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobilegateway_Protos_LogoutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogoutRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mobilegateway_Protos_LogoutRequest, rhs: Mobilegateway_Protos_LogoutRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobilegateway_Protos_LogoutResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogoutResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mobilegateway_Protos_LogoutResponse, rhs: Mobilegateway_Protos_LogoutResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobilegateway_Protos_RefreshNotificationTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefreshNotificationTokenRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mobilegateway_Protos_RefreshNotificationTokenRequest, rhs: Mobilegateway_Protos_RefreshNotificationTokenRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobilegateway_Protos_RefreshNotificationTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefreshNotificationTokenResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mobilegateway_Protos_RefreshNotificationTokenResponse, rhs: Mobilegateway_Protos_RefreshNotificationTokenResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobilegateway_Protos_SetNickNameRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetNickNameRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vehicle_id"),
    2: .same(proto: "nickname"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.vehicleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vehicleID.isEmpty {
      try visitor.visitSingularStringField(value: self.vehicleID, fieldNumber: 1)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mobilegateway_Protos_SetNickNameRequest, rhs: Mobilegateway_Protos_SetNickNameRequest) -> Bool {
    if lhs.vehicleID != rhs.vehicleID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobilegateway_Protos_SetNickNameResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetNickNameResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mobilegateway_Protos_SetNickNameResponse, rhs: Mobilegateway_Protos_SetNickNameResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobilegateway_Protos_SetSubscriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetSubscriptionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mobilegateway_Protos_SetSubscriptionRequest, rhs: Mobilegateway_Protos_SetSubscriptionRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobilegateway_Protos_SetSubscriptionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetSubscriptionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mobilegateway_Protos_SetSubscriptionResponse, rhs: Mobilegateway_Protos_SetSubscriptionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
